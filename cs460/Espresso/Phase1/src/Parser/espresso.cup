package Parser;

import Scanner.Scanner;
import AST.*;
import Utilities.Error;


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {: 
  public Scanner lexer;

  public parser(Scanner l) {
    this();
    lexer=l;
  }

  public void syntax_error(java_cup.runtime.Symbol current) {
    if(current.value == null) {
      System.out.println("Unexpected end of file." + Scanner.curLine);
      System.exit(1);
    }	
    else {
      Token t = (Token)current.value;
	System.out.println(Error.fileName + ":" + Scanner.lineCount + ": Syntax error:\n\n" + Scanner.curLine);
	for (int i=1; i<Scanner.curLine.length()+1-t.getLexeme().length(); i++) 
	  System.out.print(" ");
        System.out.println("^");

      System.exit(1);
    }
  }
:};

scan with {: return lexer.next_token(); :};

// -----------------------------------------------------------------------------
// Terminals
// -----------------------------------------------------------------------------

// Note: The order here must be that of the names[] array in Token.java

// Types
terminal Token BYTE, CHAR, SHORT, INT, LONG;  								// integrals
terminal Token FLOAT, DOUBLE;  												// decimals
terminal Token BOOLEAN;  													// booleans
terminal Token STRING;  													// strings

// Keywords
terminal Token BREAK;  														// break
terminal Token CLASS;  														// class
terminal Token CONTINUE;													// continue
terminal Token IF, ELSE;													// conditionals
terminal Token WHILE, DO, FOR;												// loops
terminal Token NEW, SUPER, THIS, EXTENDS; 											// object keywords
terminal Token VOID, RETURN;												// return keywords

// Modifiers
terminal Token PUBLIC, PRIVATE, STATIC; 									// access modifiers
terminal Token FINAL; 														// non-access modifiers

// Literals and Identifiers
terminal Token BOOLEAN_LITERAL,
               FLOAT_LITERAL,
               DOUBLE_LITERAL,
               IDENTIFIER,
               INTEGER_LITERAL,
               LONG_LITERAL,
               NULL_LITERAL,
               STRING_LITERAL,
               CHARACTER_LITERAL;											// literals

// Operators
terminal Token EQ; 															// assignment op
terminal Token LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ, ANDAND, OROR; 				// comparisons ops
terminal Token PLUSPLUS, MINUSMINUS, PLUS, MINUS, MULT, DIV, MOD; 			// mathematical ops
terminal Token COMP, NOT; 													// inverts
terminal Token AND, XOR, OR; 												// binary comparison ops
terminal Token LSHIFT, RSHIFT, RRSHIFT; 									// binary shift ops
terminal Token MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, MODEQ, XOREQ,
			   LSHIFTEQ, RSHIFTEQ, RRSHIFTEQ, ANDEQ, OREQ; 					// misc assignment ops

// Misc
terminal Token SEMICOLON, COLON, COMMA, DOT;								// misc symbols
terminal Token INSTANCEOF;													// instanceof
terminal Token IMPORT;														// import

// Brackets
// YOUR CODE HERE
terminal Token LBRACE, RBRACE, 												// []
               LPAREN, RPAREN, 												// ()
               LBRACK, RBRACK; 												// {}

// -----------------------------------------------------------------------------
// Non terminals
// -----------------------------------------------------------------------------

// Note: Order doesn't matter, but do it in the same blocks as in the grammar.

// 19.2) The Syntactic Grammar
non terminal AST goal;

// 19.3) Lexical Structure
non terminal AST literal;

// 19.4) Types, Values, and Variables
non terminal AST type;
non terminal AST primitive_type;
non terminal AST reference_type;
non terminal AST class_or_interface_type;
non terminal AST class_type;

// 19.5) names
non terminal AST name;

// 19.6) Packages
non terminal AST compilation_unit;
non terminal AST import_declarations_opt;
non terminal AST import_declarations;
non terminal AST import_declaration;
non terminal AST type_declarations_opt;
non terminal AST type_declarations;
non terminal AST type_declaration;
 
// 19.7) Productions used only in the LALR(1) grammar
non terminal AST modifiers_opt;
non terminal AST modifiers;
non terminal AST modifier;

// 19.8) Classes
// 19.8.1) Class Declaration
non terminal AST class_declaration;
non terminal AST super_opt;
non terminal AST super;
non terminal AST class_body;
non terminal AST class_body_declarations_opt;
non terminal AST class_body_declarations;
non terminal AST class_body_declaration;

// 19.8.2) Field Declarations
non terminal AST field_declaration;
non terminal AST variable_declarators;
non terminal AST variable_declarator;
non terminal AST variable_declarator_id;
non terminal AST variable_initializer;

// 19.8.3) Method Declarations
non terminal AST method_declaration;
non terminal AST method_body;
non terminal AST formal_parameter_list_opt;
non terminal AST formal_parameter_list;
non terminal AST formal_parameter;

// 19.8.4) Static Initializers
non terminal AST static_initializer;

// 19.8.5) Constructor Declarations
non terminal AST constructor_declaration;
non terminal AST constructor_body;
non terminal AST explicit_constructor_invocation;

// 19.9) Interfaces
// 19.9.1) Interface Declarations
// YOUR CODE HERE

// 19.10) Arrays
// YOUR CODE HERE

// 19.11) Blocks and Statements
non terminal AST block;
non terminal AST block_statements_opt;
non terminal AST block_statements;
non terminal AST block_statement;
non terminal AST local_variable_declaration;
non terminal AST statement;
non terminal AST statement_no_short_if;
non terminal AST statement_without_trailing_substatement;
non terminal AST empty_statement;
non terminal AST expression_statement;
non terminal AST statement_expression;
non terminal AST if_then_statement;
non terminal AST if_then_else_statement;
non terminal AST if_then_else_statement_no_short_if;
non terminal AST do_statement;
non terminal AST while_statement;
non terminal AST while_statement_no_short_if;
non terminal AST for_statement;
non terminal AST for_statement_no_short_if;
non terminal AST for_init_opt;
non terminal AST for_init;
non terminal AST for_update_opt;
non terminal AST for_update;
non terminal AST statement_expression_list;
non terminal AST break_statement;
non terminal AST continue_statement;
non terminal AST return_statement;

// 19.12) Expressions
non terminal AST primary;
non terminal AST primary_no_new_array;
non terminal AST class_instance_creation_expression;
non terminal AST argument_list_opt;
non terminal AST argument_list;
non terminal AST field_access;
non terminal AST method_invocation;
non terminal AST postfix_expression;
non terminal AST post_increment_expression;
non terminal AST post_decrement_expression;
non terminal AST unary_expression;
non terminal AST pre_increment_expression;
non terminal AST pre_decrement_expression;
non terminal AST unary_expression_not_plus_minus;
non terminal AST cast_expression;
non terminal AST multiplicative_expression;
non terminal AST additive_expression;
non terminal AST shift_expression;
non terminal AST relational_expression;
non terminal AST equality_expression;
non terminal AST and_expression;
non terminal AST exclusive_or_expression;
non terminal AST inclusive_or_expression;
non terminal AST conditional_and_expression;
non terminal AST conditional_or_expression;
non terminal AST conditional_expression;
non terminal AST assignment_expression;
non terminal AST assignment;
non terminal AST assignment_operator;
non terminal AST left_hand_side;
non terminal AST expression_opt;
non terminal AST expression;


start with goal;

// -----------------------------------------------------------------------------
// 19.2) The Syntactic Grammar
// -----------------------------------------------------------------------------

goal 										::=	compilation_unit;
// -----------------------------------------------------------------------------
// 19.3) Lexical Structure.
// -----------------------------------------------------------------------------

literal 									::=	INTEGER_LITERAL
											|   LONG_LITERAL
											|   FLOAT_LITERAL
											|   DOUBLE_LITERAL
											|	BOOLEAN_LITERAL
											|	STRING_LITERAL
											|	NULL_LITERAL
											|   CHARACTER_LITERAL
											;

// -----------------------------------------------------------------------------
// 19.4) Types, Values, and Variables
// -----------------------------------------------------------------------------

type 										::= primitive_type | reference_type;
primitive_type  							::= BOOLEAN
											|	BYTE
											|	SHORT
											|	INT
											|	LONG
											|	FLOAT
											|	DOUBLE
											|	CHAR
											|	STRING
											;
reference_type          					::= class_or_interface_type;
class_or_interface_type 					::= name;
class_type              					::= class_or_interface_type;

// -----------------------------------------------------------------------------
// 19.5) Names
// -----------------------------------------------------------------------------

name 										::= IDENTIFIER;

// -----------------------------------------------------------------------------
// 19.6) Packages
// -----------------------------------------------------------------------------

compilation_unit         					::= import_declarations_opt type_declarations_opt;
import_declarations_opt  					::= import_declarations | ;
import_declarations      					::= import_declaration | import_declarations import_declaration;
import_declaration       					::= IMPORT name SEMICOLON;
type_declarations_opt    					::= type_declarations | ;
type_declarations 							::= type_declaration | type_declarations type_declaration;
type_declaration 							::= class_declaration;

// -----------------------------------------------------------------------------
// 19.7) Productions used only in the LALR(1) grammar
// -----------------------------------------------------------------------------

modifiers_opt 								::= modifier | ;
modifiers 									::= modifier | modifiers modifier;
modifier 									::=	PUBLIC
											|	PRIVATE
											|	STATIC
											|	FINAL
											;

// -----------------------------------------------------------------------------
// 19.8) Classes
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// 19.8.1) Class Declaration:
// -----------------------------------------------------------------------------

class_declaration 							::= modifiers_opt CLASS name super_opt class_body;
super_opt 									::= super | ;
super 										::= EXTENDS class_type;
class_body 									::= LBRACK class_body_declarations_opt RBRACK;
class_body_declarations_opt 				::= class_body_declarations | ;
class_body_declarations 					::= class_body_declaration | class_body_declarations class_body_declaration;
class_body_declaration  					::=	field_declaration
											|	method_declaration
											|	static_initializer
											|	constructor_declaration
											;


// -----------------------------------------------------------------------------
// 19.8.2) Field Declarations
// -----------------------------------------------------------------------------

field_declaration 							::= modifiers_opt type variable_declarators SEMICOLON;
variable_declarators 						::= variable_declarator | variable_declarators COMMA variable_declarator;
variable_declarator 						::= variable_declarator_id | variable_declarator_id EQ variable_initializer;
variable_declarator_id 						::= name;
variable_initializer 						::= expression;

// -----------------------------------------------------------------------------
// 19.8.3) Method Declarations
// -----------------------------------------------------------------------------

method_declaration 							::=  modifiers_opt type name LPAREN formal_parameter_list_opt RPAREN method_body
											|	modifiers_opt VOID name LPAREN formal_parameter_list_opt RPAREN method_body;
method_body 								::= block | SEMICOLON;
formal_parameter_list_opt 					::= formal_parameter_list | ;
formal_parameter_list 						::= formal_parameter | formal_parameter_list COLON formal_parameter;
formal_parameter 							::= type variable_declarator_id;

// -----------------------------------------------------------------------------
// 19.8.4) Static Initializers
// -----------------------------------------------------------------------------

static_initializer ::= STATIC block;

// -----------------------------------------------------------------------------
// 19.8.5) Constructor Declarations
// -----------------------------------------------------------------------------

constructor_declaration 					::= modifiers_opt name LPAREN formal_parameter_list_opt RPAREN constructor_body;
constructor_body        					::= LBRACK explicit_constructor_invocation block_statements RBRACK
											|	LBRACK explicit_constructor_invocation RBRACK
											|	LBRACK block_statements RBRACK
											|	LBRACK RBRACK
											;
explicit_constructor_invocation 			::= SUPER LPAREN argument_list_opt RPAREN SEMICOLON
											|	THIS LPAREN argument_list_opt RPAREN SEMICOLON
											;

// -----------------------------------------------------------------------------
// 19.9) Interfaces
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// 19.9.1) Interface Declarations
// -----------------------------------------------------------------------------

// YOUR CODE HERE

// -----------------------------------------------------------------------------
// 19.10) Arrays
// -----------------------------------------------------------------------------

// YOUR CODE HERE

// -----------------------------------------------------------------------------
// 19.11) Blocks and Statements
// -----------------------------------------------------------------------------

block                       				::= LBRACK block_statements_opt RBRACK;
block_statements_opt        				::= block_statements | ;
block_statements            				::= block_statement | block_statements block_statement;
block_statement             				::= local_variable_declaration SEMICOLON | statement;
local_variable_declaration  				::= type variable_declarators;
statement                   				::= statement_without_trailing_substatement
											|	if_then_statement
											|	if_then_else_statement
											|	while_statement
											|	for_statement
											;
statement_no_short_if 						::= statement_without_trailing_substatement
												|	if_then_else_statement_no_short_if
												|	while_statement_no_short_if
												|	for_statement_no_short_if
												;
statement_without_trailing_substatement 	::= block
											|	empty_statement
											|	expression_statement
											|	do_statement
											|	break_statement
											|	continue_statement
											|	return_statement
											;
empty_statement     						::= SEMICOLON;
expression_statement						::= statement_expression SEMICOLON;
statement_expression						::= assignment
												|	pre_increment_expression
												|	pre_decrement_expression
												|	post_increment_expression
												|	post_decrement_expression
												|	method_invocation
												|	class_instance_creation_expression
												;
if_then_statement                   		::= IF LPAREN expression RPAREN statement;
if_then_else_statement              		::= IF LPAREN expression RPAREN statement_no_short_if ELSE statement;
if_then_else_statement_no_short_if  		::= IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if;
do_statement                        		::= DO statement WHILE LPAREN expression RPAREN SEMICOLON;
while_statement                     		::= WHILE LPAREN expression RPAREN statement;
while_statement_no_short_if         		::= WHILE LPAREN expression RPAREN statement_no_short_if;
for_statement                       		::= FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON for_update_opt RPAREN statement;
for_statement_no_short_if           		::= FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON for_update_opt RPAREN statement_no_short_if;
for_init_opt                        		::= for_init | ;
for_init                            		::= statement_expression_list | local_variable_declaration;
for_update_opt                      		::= for_update | ;
for_update                          		::= statement_expression_list;
statement_expression_list           		::= statement_expression | statement_expression_list COLON statement_expression;
break_statement                     		::= BREAK SEMICOLON;
continue_statement                  		::= CONTINUE SEMICOLON;
return_statement                    		::= RETURN expression_opt SEMICOLON;


// -----------------------------------------------------------------------------
// 19.12) Expressions
// -----------------------------------------------------------------------------

primary										::= primary_no_new_array;
primary_no_new_array						::= literal
											|	THIS
											|	LPAREN expression RPAREN
											|	class_instance_creation_expression
											|	field_access
											|	method_invocation
											;
class_instance_creation_expression			::= NEW class_type LPAREN argument_list_opt RPAREN;
argument_list_opt							::= argument_list | ;
argument_list								::= expression | argument_list COLON expression;
field_access								::= primary DOT name
											|	SUPER DOT name
											|	name DOT name
											;
method_invocation							::= name LPAREN argument_list_opt RPAREN
											|	primary DOT name LPAREN argument_list_opt RPAREN
											|	SUPER DOT name LPAREN argument_list_opt RPAREN
											|	name DOT name LPAREN argument_list_opt RPAREN
											;
postfix_expression  						::= primary
											|	post_increment_expression
											|	post_decrement_expression
											|   name
											;
post_increment_expression  					::= postfix_expression PLUSPLUS;
post_decrement_expression  					::=	postfix_expression MINUSMINUS;
unary_expression 							::= pre_increment_expression
											|	pre_decrement_expression
											| 	PLUS unary_expression
											|	MINUS unary_expression
											|	unary_expression_not_plus_minus 
											;
pre_increment_expression 					::= PLUSPLUS unary_expression;
pre_decrement_expression 					::= MINUSMINUS unary_expression;
unary_expression_not_plus_minus 			::= postfix_expression
											|	COMP unary_expression
											|	NOT unary_expression
											|	cast_expression
											;
cast_expression 							::= LPAREN expression RPAREN unary_expression_not_plus_minus
											|	LPAREN primitive_type RPAREN unary_expression
											;
multiplicative_expression 					::=	unary_expression
											|	multiplicative_expression MULT unary_expression
											|	multiplicative_expression DIV unary_expression
											|	multiplicative_expression MOD unary_expression
											;
additive_expression 						::= multiplicative_expression
											|	additive_expression PLUS multiplicative_expression
											|	additive_expression MINUS multiplicative_expression
											;
shift_expression 							::= additive_expression
											|	shift_expression LSHIFT additive_expression
											|	shift_expression RSHIFT additive_expression
											|	shift_expression RRSHIFT additive_expression
											;
relational_expression 						::=	shift_expression 
											|	relational_expression LT shift_expression
											|	relational_expression GT shift_expression
											|	relational_expression LTEQ shift_expression
											|	relational_expression GTEQ shift_expression
											|   relational_expression INSTANCEOF name
											; 
equality_expression 						::= relational_expression
											|	equality_expression EQEQ relational_expression
											|	equality_expression NOTEQ relational_expression
											;
and_expression 								::= equality_expression
											|	and_expression AND equality_expression
											;
exclusive_or_expression 					::= and_expression
											|	exclusive_or_expression XOR and_expression
											;
inclusive_or_expression 					::= exclusive_or_expression 
											|	inclusive_or_expression OR exclusive_or_expression
											;
conditional_and_expression 					::= inclusive_or_expression
											|	conditional_and_expression ANDAND inclusive_or_expression
											;
conditional_or_expression 					::= conditional_and_expression 
											|	conditional_or_expression OROR conditional_and_expression
											;
conditional_expression 						::= conditional_or_expression;
assignment_expression 						::=	conditional_expression | assignment;
assignment 									::=	left_hand_side assignment_operator assignment_expression;
assignment_operator 						::= EQ
        									|   MULTEQ
        									|   DIVEQ
        									|   MODEQ
        									|   PLUSEQ
        									|   MINUSEQ
        									|   LSHIFTEQ
        									|   RSHIFTEQ
        									|   RRSHIFTEQ
        									|   ANDEQ
        									|   XOREQ
        									|   OREQ
											;
left_hand_side 								::= name | field_access;
expression_opt								::= expression | ; 
expression 									::=	assignment_expression;

// -----------------------------------------------------------------------------
// End of productions
// -----------------------------------------------------------------------------
